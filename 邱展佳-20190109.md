# 1. Algorithm

## k个一组翻转链表

（Reverse Nodes in k-Group）

### 题目描述

https://leetcode-cn.com/problems/reverse-nodes-in-k-group/

### 算法实现

```java
public static ListNode reverseKGroup(ListNode head, int k) {
	// 参数检查
	// 提前退出
	if (head == null || head.next == null || k == 1) {
		return head;
	}
	// 参数检查
	if (k <= 0) {
		throw new IllegalArgumentException("k must be greater than 0");
	}

	// 哨兵
	ListNode dummyHead = new ListNode(-1);
	dummyHead.next = head;
	ListNode prevs = dummyHead;
	
	// 至少有两个节点（prevs.next、prevs.next.next）才进行交换
	while (prevs != null && prevs.next != null && prevs.next.next != null) {
		prevs = reverse(prevs, prevs.next, k - 1);
	}
	
	return dummyHead.next;
}

/**
 * 反转链表
 *  
 * @param prevs 头部的前一个节点
 * @param last 尾节点（头节点传进来后，如果节点总数是 k 的整数倍，那么会一直保持为尾节点）
 * @param remain 待往前移动的节点数
 * @return
 */
private static ListNode reverse(ListNode prevs, ListNode last, int remain) {
	int count = 0;
	ListNode moveToFirst = null;
	// 每次循环，都将尾节点的下一个节点移至头节点，有点类似于插入排序
	while ((moveToFirst = last.next) != null && remain-- >= 1) {
		last.next = moveToFirst.next;
		moveToFirst.next = prevs.next;
		prevs.next = moveToFirst;
		count++;
	}
	
	// 如果节点总数是 k 的整数倍，那么 remain应该为0；
	// 如果节点总数不是 k 的整数倍，则将链表再反转回来，保持原来的顺序。
	if (remain >= 1) {
		reverse(prevs, prevs.next, count);
		return null;
	}
	return last;
}
```

# 2. Review

## 技术文章


## 总结


# 3. Technique


# 4. Share

**分享文章**：[TODO](https://mp.weixin.qq.com/s/7rOcfKiVJopXL8EECU_7_w)

**个人公众号**：二进制之路

![二进制之路](https://note.youdao.com/yws/public/resource/c590ee50585156111cc240ca1943cebf/xmlnote/021950D7D8FC4A8E91B08CDBD68547F2/80591)

