# 1. Algorithm

## 括号生成

（Generate Parentheses）

### 题目描述

https://leetcode-cn.com/problems/generate-parentheses/description/

### 算法实现

这道题费尽了脑筋，离答案还差一点点。看了答案，发现10来行就搞定了。。。

```java
public static List<String> generateParenthesis(int n) {
	init(n);
	allGroups.add(continuousPArray[n]);
	produce(n, emptyString, emptyString);
	List<String> resultList = new ArrayList<>();
	resultList.addAll(allGroups);
	return resultList;
}

public static final String leftP = "(";
public static final String rightP = ")";
public static final String oneP = "()";
public static final String emptyString = "";

private static String[] nestedPArray; // n个嵌套括号. ()、(())、((()))...
private static String[] continuousPArray; // n个连续括号. ()、()()、()()()...
private static String[] innerContinuousPArray; // 括号内n个连续括号. ()、(())、(()())、(()()())...

private static Set<String> allGroups;

private static void init(int n) {
	continuousPArray = new String[n + 1]; // n个连续括号. ()、()()、()()()...
	nestedPArray = new String[n + 1]; // n个嵌套括号. ()、(())、((()))...
	innerContinuousPArray = new String[n + 1]; // 括号内n个连续括号. ()、(())、(()())、(()()())...
	
	continuousPArray[0] = emptyString;
	nestedPArray[0] = emptyString;
	innerContinuousPArray[0] = emptyString;
	
	for (int i = 1; i <= n; i++) {
		if (i == 1) {
			nestedPArray[i] = oneP;
			continuousPArray[i] = oneP;
			innerContinuousPArray[i] = oneP;
		} else {
			continuousPArray[i] = continuousPArray[i - 1] + oneP;
			nestedPArray[i] = leftP + nestedPArray[i - 1] + rightP;
			innerContinuousPArray[i] = innerContinuousPArray[i - 1].substring(0, innerContinuousPArray[i - 1].length() - 1) + oneP + rightP;
		}
	}
	
	allGroups = new LinkedHashSet<>();
	
//		for (String str : nestedPArray) {
//			System.out.println(str);
//		}
//
//		for (String str : continuousPArray) {
//			System.out.println(str);
//		}
//		
//		for (String str : innerContinuousPArray) {
//			System.out.println(str);
//		}
//		System.out.println();
//		System.out.println("-----------");
}

/**
 * 处理连续括号部分的各种可能性
 * 
 * @param count 每次要处理的连续括号数量
 * @param fixedLeft 左边固定部分内容
 * @param fixedRight 右边固定部分内容
 */
private static void produce(int count, String fixedLeft, String fixedRight) {
	int leftIndex = 0; // 左边括号数索引，索引号与括号数相等，也相当于左边的括号数
	int rightIndex = 0; // 右边括号数索引，索引号与括号数相等，也相当于右边的括号数
	StringBuilder sb = new StringBuilder(); // 用于组装每一种结果

	final int n = count; // 每次要处理的连续括号数量
	
//		System.out.println(String.format("leftCount:%s, rightCount:%s, middleCount:%s, fixedLeft:%s, fixedRight:%s", leftCount, rightCount, middleCount, fixedLeft, fixedRight));
	
	/*
	 * n-1种嵌套括号的场景(>=2个括号)，从2个嵌套括号开始处理(nextedCount=2)
	 */
	for (int nextedCount = 2; nextedCount <= n; nextedCount++) { // nextedCount为嵌套括号个数
		leftIndex = 0;
		rightIndex = n - nextedCount;

		// 对于每一种嵌套括号，有n - nextedCount + 1种可能性
		for (int j = 0; j <= n - nextedCount; j++) {
			sb.setLength(0);
			sb.append(fixedLeft);
			sb.append(continuousPArray[leftIndex]); // 左连续括号
			sb.append(nestedPArray[nextedCount]); // 嵌套括号()、(())、((()))...
			sb.append(continuousPArray[rightIndex]); // 右连续括号
			sb.append(fixedRight);//System.out.println("+++");
			allGroups.add(sb.toString());
//				System.out.println(sb.toString());
			if ("((())())(()()())".equals(sb.toString())) {
				System.out.println(String.format("+++ count:%s, fixedLeft:%s, fixedRight:%s, nextedCount:%s", count, fixedLeft, fixedRight, nextedCount));
			}
//				if ("(()())".equals(fixedLeft) && n == 3) {
//					System.out.println(String.format("+++ count:%s, fixedLeft:%s, fixedRight:%s, nextedCount:%s", count, fixedLeft, fixedRight, nextedCount));
//				}
			
			if (leftIndex > 1) { // 左边连续括号>=2个，右边部分固定
//					if (")(()()())".equals(nestedPArray[nextedCount] + continuousPArray[rightIndex] + fixedRight)) {
					if ("(()()())".equals(nestedPArray[nextedCount] + continuousPArray[rightIndex] + fixedRight)) {
					System.out.println(String.format("leftIndex +++ count:%s, fixedLeft:%s, fixedRight:%s, nextedCount:%s, newCount:%s", count, fixedLeft,
							nestedPArray[nextedCount] + continuousPArray[rightIndex] + fixedRight, nextedCount, leftIndex));
				}
				produce(leftIndex,
						fixedLeft,
						nestedPArray[nextedCount] + continuousPArray[rightIndex] + fixedRight);
			}
			if (rightIndex > 1) { // 右边连续括号>=2个, 左边部分固定
//					if (")(()()())".equals(fixedRight)) {
					if ("(()()())".equals(fixedRight)) {
					System.out.println(String.format("rightIndex +++ count:%s, fixedLeft:%s, fixedRight:%s, nextedCount:%s, newCount:%s", count, fixedLeft + continuousPArray[leftIndex] + nestedPArray[nextedCount],
							fixedRight, nextedCount, rightIndex));
				}
				produce(rightIndex,
						fixedLeft + continuousPArray[leftIndex] + nestedPArray[nextedCount],
						fixedRight);
			}

			leftIndex++;
			rightIndex--;
		}
	}

	/*
	 * n-2种括号内连续括号的场景(>=3个括号)，从括号内2个连续括号开始处理(innerContinuousCount=3)
	 */
	for (int innerContinuousCount = 3; innerContinuousCount <= n; innerContinuousCount++) { // i为括号内连续括号个数
		leftIndex = 0;
		rightIndex = n - innerContinuousCount;
		
		// 对于每一种括号内连续括号，有n - innerContinuousCount + 1种可能性
		for (int j = 0; j <= n - innerContinuousCount; j++) {
			sb.setLength(0);
			sb.append(fixedLeft);
			sb.append(continuousPArray[leftIndex]); // 左连续括号
			sb.append(innerContinuousPArray[innerContinuousCount]); // 括号内连续括号
			sb.append(continuousPArray[rightIndex]); // 右连续括号
			sb.append(fixedRight);//System.out.println("---");
			allGroups.add(sb.toString());
//				System.out.println(sb.toString());
//				if ("((())())(()()())".equals(sb.toString())) {
//					System.out.println(String.format("--- count:%s, fixedLeft:%s, fixedRight:%s, innerContinuousCount:%s", count, fixedLeft, fixedRight, innerContinuousCount));
//				}
			
			if (leftIndex > 1) { // 左边连续括号>=2个，右边部分固定
//					if (")(()()())".equals(innerContinuousPArray[innerContinuousCount] + continuousPArray[rightIndex] + fixedRight)) {
					if ("(()()())".equals(innerContinuousPArray[innerContinuousCount] + continuousPArray[rightIndex] + fixedRight)) {
					System.out.println(String.format("leftIndex --- count:%s, fixedLeft:%s, fixedRight:%s, innerContinuousCount:%s, newCount:%s, continuousPArray[rightIndex]:%s, fixedRight:%s", count, fixedLeft,
							innerContinuousPArray[innerContinuousCount] + continuousPArray[rightIndex] + fixedRight, innerContinuousCount, leftIndex, continuousPArray[rightIndex], fixedRight));
				}
				produce(leftIndex,
						fixedLeft,
						innerContinuousPArray[innerContinuousCount] + continuousPArray[rightIndex] + fixedRight);
			}
			if (rightIndex > 1) { // 右边连续括号>=2个, 左边部分固定
//					if (")(()()())".equals(fixedRight)) {
					if ("(()()())".equals(fixedRight)) {
					System.out.println(String.format("rightIndex --- count:%s, fixedLeft:%s, fixedRight:%s, innerContinuousCount:%s, newCount:%s", count, fixedLeft + continuousPArray[leftIndex] + innerContinuousPArray[innerContinuousCount],
							fixedRight, innerContinuousCount, rightIndex));
				}
				produce(rightIndex,
						fixedLeft + continuousPArray[leftIndex] + innerContinuousPArray[innerContinuousCount],
						fixedRight);
			}
			if (innerContinuousCount > 2) { // 括号内连续括号>=2个, 左右两边的内容作为固定部分
//					if (")(()()())".equals(rightP + continuousPArray[rightIndex] + fixedRight)) {
					if ("(()()())".equals(rightP + continuousPArray[rightIndex] + fixedRight)) {
					System.out.println(String.format("innerContinuousCount --- count:%s, fixedLeft:%s, fixedRight:%s, innerContinuousCount:%s, newCount:%s, continuousPArray[rightIndex]:%s, fixedRight:%s", count, fixedLeft + continuousPArray[leftIndex] + leftP,
							rightP + continuousPArray[rightIndex] + fixedRight, innerContinuousCount, innerContinuousCount - 1, continuousPArray[rightIndex], fixedRight));
				}
				produce(innerContinuousCount - 1,
						fixedLeft + continuousPArray[leftIndex] + leftP,
						rightP + continuousPArray[rightIndex] + fixedRight);
			}
			
			leftIndex++;
			rightIndex--;
		}
	}
}
```

# 2. Review

## 技术文章

TODO

## 总结

TODO

# 3. Technique


# 4. Share

**分享文章**：[TODO](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

**个人公众号**：二进制之路

![二进制之路](https://note.youdao.com/yws/public/resource/c590ee50585156111cc240ca1943cebf/xmlnote/021950D7D8FC4A8E91B08CDBD68547F2/80591)

